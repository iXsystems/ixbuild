#!/usr/bin/env bash
# Author: Kris Moore
# License: BSD
# Location for tests into REST API of FreeNAS 9.10
# Resty Docs: https://github.com/micha/resty
# jsawk: https://github.com/micha/jsawk

# List the other modules which must be run before this module can execute
REQUIRES="storage"
export REQUIRES

replication_tests()
{
  set_test_group_text "1 - Create - Replication Tests" "24"
  CLASSNAME=ixbuild.resty.functional.create.replication

  # * PUSH = system generating the ZFS snapshots
  # * PULL = system to receive a copy of the ZFS snapshot

  # Datasets which will be created to host and store the snapshot via replication task
  local PUSH_DATASET="repldata01"
  local PULL_DATASET="repldata01"

  # Set the replication dataset name to something unique for this test executor
  if [ -n "${BRIDGEHOST}" ]; then
    PULL_DATASET="${BRIDGEHOST}"
    PUSH_DATASET="${BRIDGEHOST}"
  fi

  local PUSH_DATASET_PATH="/mnt/tank/${PUSH_DATASET}/"
  local PULL_DATASET_PATH="/mnt/tank/${PULL_DATASET}/"

  # Respective locations for the ssh pub key which will be used for authentication
  local PUSH_SSHKEY_PATH="/data/ssh/replication.pub"
  local PULL_SSHKEY_PATH="/etc/local/ssh/ssh_host_rsa_key.pub"

  # Common path and filename used for copying pub keys from both the PUSH and PULL servers
  local PUSH_TMP_SSHKEY_PATH="/tmp/push_sshkeys${BRIDGEHOST}.pub"
  local PULL_TMP_SSHKEY_PATH="/tmp/pull_sshkeys${BRIDGEHOST}.pub"

  # List of dummie filesystem objects to be created to test recursive replication
  local TEST_FILES=( "testfile.txt" "testdir/testfile2.txt" )

  local REQUIRED_SETTINGS=( "REPLTARGET" "REPLUSERNAME" "REPLPASSWORD" "REPLVOLUME" )
  for SETTING in "${REQUIRED_SETTINGS[@]}"
  do
    if [ -z "${!SETTING}" ]; then
      echo -n "Required settings for replication: '${REQUIRED_SETTINGS[*]}'; missing ${SETTING}"
      echo_skipped
      return 0
    fi
  done

  # Clean up any leftover items from previous failed replication tests

  # Remove replication tasks
  rest_request "GET" "/storage/replication/"
  local repl_id_list=$(cat $RESTYOUT | ${JSAWK} -n 'if (this.repl_remote_hostname == "'"${REPLTARGET}"'" && this.repl_filesystem == "tank/'"${PUSH_DATASET}"'") { out(this.id) }')
  for repl_id in ${repl_id_list[@]}; do rest_request "DELETE" "/storage/replication/${repl_id}/"; done

  # Remove snapshot tasks
  rest_request "GET" "/storage/task/"
  local snapshot_id_list=$(cat $RESTYOUT | ${JSAWK} -n 'if (this.task_filesystem == "tank/'"${PUSH_DATASET}"'") { out(this.id) }')
  for snapshot_id in ${snapshot_id_list[@]}; do rest_request "DELETE" "/storage/task/${snapshot_id}/"; done

  # Remove datasets and leftover tmp files
  repl_rest_request "DELETE" "/storage/volume/1/datasets/${PULL_DATASET}%2F${PUSH_DATASET}/"
  repl_rest_request "DELETE" "/storage/volume/1/datasets/${PULL_DATASET}/"
  rest_request "DELETE" "/storage/volume/1/datasets/${PUSH_DATASET}/"
  rm "${PUSH_TMP_SSHKEY_PATH}" &>/dev/null
  rm "${PULL_TMP_SSHKEY_PATH}" &>/dev/null

  # Create datasets on PUSH and PULL replication hosts, set permissions on dataset

  echo_test_title "Creating \"${PUSH_DATASET}\" dataset for replication"
  rest_request "POST" "/storage/volume/tank/datasets/" '{ "name": "'"${PUSH_DATASET}"'" }'
  check_rest_response "201 Created" || return 1

  echo_test_title "Changing permissions on \"${PUSH_DATASET_PATH}\""
  rest_request "PUT" "/storage/permission/" '{ "mp_path": "'"${PUSH_DATASET_PATH}"'", "mp_acl": "unix", "mp_mode": "777", "mp_user": "root", "mp_group": "wheel" }'
  check_rest_response "201 Created" || return 1

  echo_test_title "Creating \"${PULL_DATASET}\" dataset on replication target host"
  repl_rest_request "POST" "/storage/volume/${REPLVOLUME}/datasets/" '{ "name": "'"${PULL_DATASET}"'" }'
  check_rest_response "201 Created" || return 1

  echo_test_title "Changing permissions on \"${PULL_DATASET}\" dataset on replication target host"
  repl_rest_request "PUT" "/storage/permission/" '{ "mp_path": "/mnt/'"${REPLVOLUME}/${PULL_DATASET}"'", "mp_acl": "unix", "mp_mode": "777", "mp_user": "root", "mp_group": "wheel" }'
  check_rest_response "201 Created" || return 1

  # Add files/directories to dataset
  for uri in ${TEST_FILES[@]}
  do
    local dir_name="$(dirname "$uri")"
    echo_test_title "Creating file \"${uri}\" on the dataset \"${PUSH_DATASET_PATH}\""
    if [ "." == "${dir_name}" -a -n "${uri}" ]; then
      ssh_test "touch \"${PUSH_DATASET_PATH}${uri}\""
    else
      ssh_test "mkdir -p \"${PUSH_DATASET_PATH}${dir_name}\" && touch \"${PUSH_DATASET_PATH}${uri}\""
    fi
  done

  # Create a periodic snapshot to replicate
  local task_begin="$(date "+%H:%M:%S")"
  local task_end="$(date -v +30M "+%H:%M:%S")"
  echo_test_title "Create snapshot task for \"tank/${PUSH_DATASET}\""
  rest_request "POST" "/storage/task/" '{ "task_repeat_unit": "daily", "task_begin": "'"${task_begin}"'", "task_end": "'"${task_end}"'", "task_filesystem": "tank/'"${PUSH_DATASET}"'", "task_ret_unit": "day", "task_interval": "15", "task_enabled": true, "task_recursive": true }'
  check_rest_response "201 Created" || return 1

  # Fetch SSH public keys from the PUSH and PULL hosts

  echo_test_title "Fetch SSH public key from our PUSH host"
  scp_from_test "${PUSH_SSHKEY_PATH}" "${PUSH_TMP_SSHKEY_PATH}" || return 1
  local push_user_pubkey="`grep -v '^$' ${PUSH_TMP_SSHKEY_PATH} | tr -d '\n'`"

  echo_test_title "Fetch SSH public key from our PULL host"
  scp_from_repl "${PULL_SSHKEY_PATH}" "${PULL_TMP_SSHKEY_PATH}" || return 1
  local pull_user_pubkey="`grep -v '^$' ${PULL_TMP_SSHKEY_PATH} | tr -d '\n'`"

  # Get the root user's ID and add our PULL SSH public key to the account

  echo_test_title "Get the ID for the root user account on our PULL host"
  repl_rest_request "GET" "/account/users/"
  check_rest_response "200" || return 1
  local pull_root_user_id=$(cat "$RESTYOUT" | jsawk -n 'if (this.bsdusr_username == "root") { out(this.id) }')

  echo_test_title "Add our SSH public key to the root user account on our PULL host"
  repl_rest_request "PUT" "/account/users/${pull_root_user_id}/" '{ "bsdusr_sshpubkey": "'"${push_user_pubkey}"'" }'
  check_rest_response "200"  || return 1

  echo_test_title "Add ECDSA auth to our the root user's \".ssh/known_hosts\""
  ssh_test "ssh-keyscan ${REPLTARGET} >> \"/root/.ssh/known_hosts\"" || return 1

  # Create replication job for our snapshot, using the PULL SSH public key
  local repl_begin="$(date "+%H:%M:%S")"
  local repl_end="$(date -v +30M "+%H:%M:%S")"
  echo_test_title "Create replication job for the snapshot \"${PUSH_DATASET}\""
  rest_request "POST" "/storage/replication/" '{ "repl_filesystem": "tank/'"${PUSH_DATASET}"'", "repl_zfs": "'"${REPLVOLUME}/${PULL_DATASET}"'", "repl_remote_hostname": "'"${REPLTARGET}"'", "repl_begin": "'"${repl_begin}"'", "repl_end": "'"${repl_end}"'", "repl_enabled": true, "repl_remote_cipher": "standard", "repl_remote_hostkey": "'"${pull_user_pubkey}"'" }'
  check_rest_response "201 Created" || return 1
  local repl_id="`cat ${RESTYOUT} | ${JSAWK} -n 'out(this.id)'`"

  # Check/poll replication job's repl_status for 'Succeeded' status
  echo_test_title "Verify that replication job succeeded for snapshot \"${PUSH_DATASET}\""
  local poll_cnt=30
  until [ $poll_cnt -lt 1 ]; do
    let poll_cnt-=1
    rest_request "GET" "/storage/replication/${repl_id}/"
    if [ $poll_cnt -eq 0 ]; then
      # Last attempt, print exit status
      check_property_value "return this.repl_status" "Succeeded"
    else
      # Silent, only print success or re-try
      check_property_value -q "return this.repl_status" "Succeeded"
      if [ "$?" == "0" ]; then
        echo_ok
        break
      fi
    fi
    sleep 3
  done

  # Verify that files and directories were created on target PULL host
  for uri in ${TEST_FILES[@]}
  do
    local dir_name="$(dirname "$uri")"
    echo_test_title "Verify that \"${uri}\" was created on the replication target"
    if [ "." == "${dir_name}" -a -n "${uri}" ]; then
      ssh_repl_test "test -f \"${PULL_DATASET_PATH}/${PUSH_DATASET}/${uri}\""
    else
      ssh_repl_test "test -d \"${PULL_DATASET_PATH}/${PUSH_DATASET}/${dir_name}\" && test -f \"${PULL_DATASET_PATH}/${PUSH_DATASET}/${uri}\""
    fi
  done

  echo_test_title "Delete the replication job for snapshot \"${PUSH_DATASET}\""
  rest_request "DELETE" "/storage/replication/${repl_id}/"
  check_rest_response "204" || return 1

  rest_request "GET" "/storage/task/"
  local snapshot_tasks=$(cat ${RESTYOUT} | ${JSAWK} -n 'if (this.task_filesystem == "tank/'"${PUSH_DATASET}"'") { out(this.id) }')
  for snapshot_id in ${snapshot_tasks[@]}
  do
    echo_test_title "Delete the snapshot task \"tank/${PUSH_DATASET}\"(${snapshot_id})"
    rest_request "DELETE" "/storage/task/${snapshot_id}/"
    check_rest_response "204"
  done

  # Snapshot ID example: tank/bridgehost/bridgehost@auto-20170417.1632-2d
  repl_rest_request "GET" "/storage/snapshot/"
  local replicated_snapshots=$(cat ${RESTYOUT} | ${JSAWK} -n 'if (this.filesystem == "'"${REPLVOLUME}/${PULL_DATASET}/${PUSH_DATASET}"'") { out(this.id) }')
  for snapshot_id in ${replicated_snapshots[@]}
  do
    echo_test_title "Deleting replicated snapshot \"${snapshot_id}\" from replication target"
    # repl_rest_request uses curl cmd instead of resty, requires some escaping of special chars
    repl_rest_request "DELETE" "/storage/snapshot/$(echo ${snapshot_id} | sed 's|/|%2F|g' | sed 's|@|%40|g')/"
    check_rest_response "204"
  done 

  echo_test_title "Delete the replication target child dataset \"${PULL_DATASET}/${PUSH_DATASET}\""
  repl_rest_request "DELETE" "/storage/volume/1/datasets/${PULL_DATASET}%2F${PUSH_DATASET}"
  check_rest_response "204" || return 1


  rest_request "GET" "/storage/snapshot/"
  local snapshots=$(cat ${RESTYOUT} | ${JSAWK} -n 'if (this.filesystem == "tank/'"${PUSH_DATASET}"'") { out(this.id) }')
  for snapshot_id in ${snapshots[@]}
  do
    echo_test_title "Deleting testing target snapshot \"${snapshot_id}\""
    rest_request "DELETE" "/storage/snapshot/${snapshot_id}/"
    check_rest_response "204"
  done

  echo_test_title "Delete the replication target dataset \"${PULL_DATASET}\""
  repl_rest_request "DELETE" "/storage/volume/1/datasets/${PULL_DATASET}/"
  check_rest_response "204" || return 1

  if [ -n "${PUSH_DATASET_PATH}" ] && [ "$PUSH_DATASET_PATH" != "/" ]; then
    echo_test_title "Delete all file objects create on the testing target"
    ssh_test "test -d \"${PUSH_DATASET_PATH}\" && rm -rf \"${PUSH_DATASET_PATH}/*\""
  fi

  echo_test_title "Delete the testing target dataset \"${PUSH_DATASET}\""
  rest_request "DELETE" "/storage/volume/1/datasets/${PUSH_DATASET}/"
  check_rest_response "204" || return 1

  return 0
}

# Init function, this is called after module is sourced
# Pre-Set variables
# TESTSET = ( SMOKE / COMPLETE / BENCHMARK )
replication_init()
{
  # Run all the storage tests
  case $TESTSET in
        SMOKE) replication_tests ;;
     COMPLETE) replication_tests ;;
    BENCHMARK) ;;
            *) replication_tests ;;
  esac
}
